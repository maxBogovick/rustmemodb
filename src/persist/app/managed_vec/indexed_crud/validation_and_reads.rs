impl<V> ManagedPersistVec<V>
where
    V: PersistIndexedCollection,
{
    /// Validates unique constraints for all items in the collection.
    ///
    /// Checks that fields marked as unique in the schema do not have duplicate values.
    /// Uses serialized values to handle complex types uniformly.
    fn validate_unique_constraints(&self) -> Result<()> {
        // Validate against serialized entity state so the check works for any model generated by
        // persist_struct! without requiring repository-layer duplicate lookup code.
        let mut seen = std::collections::HashMap::<(&'static str, String), String>::new();

        for item in self.collection.items() {
            let unique_fields = item.unique_fields();
            if unique_fields.is_empty() {
                continue;
            }

            let state = item.state();
            let fields = state.fields.as_object().ok_or_else(|| {
                DbError::ExecutionError(format!(
                    "Persist state fields must be a JSON object for unique validation: {}:{}",
                    item.table_name(),
                    item.persist_id()
                ))
            })?;

            for field in unique_fields {
                let value = fields.get(field).ok_or_else(|| {
                    DbError::ExecutionError(format!(
                        "Unique field '{}' is missing in persist state for {}:{}",
                        field,
                        item.table_name(),
                        item.persist_id()
                    ))
                })?;

                let normalized_value = serde_json::to_string(value).map_err(|err| {
                    DbError::ExecutionError(format!(
                        "Failed to serialize unique field '{}' for {}:{}: {}",
                        field,
                        item.table_name(),
                        item.persist_id(),
                        err
                    ))
                })?;

                let key = (field, normalized_value.clone());
                if let Some(existing_persist_id) = seen.get(&key) {
                    if existing_persist_id != item.persist_id() {
                        return Err(DbError::ConstraintViolation(format!(
                            "unique constraint violation on '{}.{}': value {} already exists (persist_id='{}')",
                            self.name, field, normalized_value, existing_persist_id
                        )));
                    }
                } else {
                    seen.insert(key, item.persist_id().to_string());
                }
            }
        }

        Ok(())
    }

    /// Internal helper that validates constraints before delegates to the collection's save.
    async fn save_all_checked(&mut self, session: &PersistSession) -> Result<()> {
        self.validate_unique_constraints()?;
        self.collection.save_all(session).await
    }

    /// Returns a slice of all items in the collection.
    pub fn list(&self) -> &[V::Item] {
        self.collection.items()
    }

    /// Retrieves a single item by its persistent ID.
    ///
    /// Returns `None` if the item does not exist or is marked as deleted/not persisted.
    pub fn get(&self, persist_id: &str) -> Option<&V::Item> {
        self.collection
            .items()
            .iter()
            .find(|item| item.persist_id() == persist_id && item.metadata().persisted)
    }

    /// Returns a paginated list of items.
    ///
    /// Skips `offset` items and returns at most `limit` items.
    /// Only returns items that are persisted (not deleted).
    pub fn list_page(&self, offset: usize, limit: usize) -> Vec<&V::Item> {
        if limit == 0 {
            return Vec::new();
        }

        self.collection
            .items()
            .iter()
            .filter(|item| item.metadata().persisted)
            .skip(offset)
            .take(limit)
            .collect()
    }

    /// Returns items filtering by an arbitrary predicate.
    ///
    /// Only items that pass both the predicate and are persisted are returned.
    pub fn list_filtered<F>(&self, predicate: F) -> Vec<&V::Item>
    where
        F: Fn(&V::Item) -> bool,
    {
        self.collection
            .items()
            .iter()
            .filter(|item| item.metadata().persisted)
            .filter(|item| predicate(item))
            .collect()
    }

    /// Returns a new vector of items sorted by the provided comparison function.
    ///
    /// Does not modify the underlying storage order.
    pub fn list_sorted_by<F>(&self, mut compare: F) -> Vec<&V::Item>
    where
        F: FnMut(&V::Item, &V::Item) -> Ordering,
    {
        let mut items = self
            .collection
            .items()
            .iter()
            .filter(|item| item.metadata().persisted)
            .collect::<Vec<_>>();
        items.sort_by(|left, right| compare(left, right));
        items
    }
}
