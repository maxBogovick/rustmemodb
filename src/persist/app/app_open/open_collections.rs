impl PersistApp {
    /// Opens a managed collection by logical name.
    ///
    /// If a snapshot file exists, it is restored before the collection is returned.
    pub async fn open_vec<V>(&self, name: impl Into<String>) -> Result<ManagedPersistVec<V>>
    where
        V: PersistCollection,
    {
        let name = name.into();
        let snapshot_path = self.snapshot_path_for(&name);
        let mut collection = V::new_collection(name.clone());
        let mut last_snapshot_at = None;

        if fs::try_exists(&snapshot_path).await.map_err(|err| {
            DbError::ExecutionError(format!(
                "Failed to check snapshot path '{}': {}",
                snapshot_path.display(),
                err
            ))
        })? {
            let bytes = fs::read(&snapshot_path).await.map_err(|err| {
                DbError::ExecutionError(format!(
                    "Failed to read snapshot '{}': {}",
                    snapshot_path.display(),
                    err
                ))
            })?;

            if !bytes.is_empty() {
                let snapshot: V::Snapshot = serde_json::from_slice(&bytes).map_err(|err| {
                    DbError::ExecutionError(format!(
                        "Failed to decode snapshot '{}': {}",
                        snapshot_path.display(),
                        err
                    ))
                })?;

                collection
                    .restore_with_policy(
                        snapshot,
                        &self.session,
                        RestoreConflictPolicy::OverwriteExisting,
                    )
                    .await?;
                last_snapshot_at = Some(Utc::now().to_rfc3339());
            }
        }

        Ok(ManagedPersistVec {
            name,
            collection,
            session: self.session.clone(),
            snapshot_path,
            snapshot_every_ops: self.policy.snapshot_every_ops.max(1),
            ops_since_snapshot: 0,
            replication: self.policy.replication.clone(),
            replication_failures: 0,
            last_snapshot_at,
        })
    }

    /// Opens an aggregate store wrapper over a managed collection.
    pub async fn open_aggregate<V>(
        &self,
        name: impl Into<String>,
    ) -> Result<PersistAggregateStore<V>>
    where
        V: PersistCollection,
    {
        let managed = self.open_vec::<V>(name).await?;
        Ok(PersistAggregateStore::new(managed))
    }

    /// Opens an autonomous aggregate and its paired audit collection.
    ///
    /// The audit collection name is derived as `<name>__audit`.
    pub async fn open_autonomous<V>(
        &self,
        name: impl Into<String>,
    ) -> Result<PersistAutonomousAggregate<V>>
    where
        V: PersistCollection,
    {
        let aggregate_name = name.into();
        let aggregate = self.open_aggregate::<V>(aggregate_name.clone()).await?;
        let audits = self
            .open_aggregate::<PersistAuditRecordVec>(format!("{aggregate_name}__audit"))
            .await?;
        let rest_idempotency = self
            .open_aggregate::<PersistRestIdempotencyRecordVec>(format!(
                "{aggregate_name}__rest_idempotency"
            ))
            .await?;
        Ok(PersistAutonomousAggregate::new(
            aggregate,
            audits,
            rest_idempotency,
            self.policy.conflict_retry.clone(),
        ))
    }

    /// Alias for `open_autonomous` used by high-level domain code.
    pub async fn open_domain<V>(&self, name: impl Into<String>) -> Result<PersistDomainStore<V>>
    where
        V: PersistCollection,
    {
        self.open_autonomous(name).await
    }

    /// Opens a thread-safe domain handle with `&self` methods.
    ///
    /// This is the default ergonomic entrypoint for application code that
    /// should not manage `Arc<Mutex<...>>` around persistence stores.
    pub async fn open_domain_handle<V>(
        &self,
        name: impl Into<String>,
    ) -> Result<PersistDomainHandle<V>>
    where
        V: PersistCollection,
    {
        let store = self.open_domain::<V>(name).await?;
        Ok(PersistDomainHandle::new(store))
    }

    /// Opens autonomous source-model handle generated by `#[derive(Autonomous)]`.
    pub async fn open_autonomous_model<M>(
        &self,
        name: impl Into<String>,
    ) -> Result<PersistAutonomousModelHandle<M>>
    where
        M: PersistAutonomousModel,
    {
        let handle = self.open_domain_handle::<M::Collection>(name).await?;
        Ok(PersistAutonomousModelHandle::new(handle))
    }

    /// Opens an autonomous model and returns a generated REST router for it.
    ///
    /// This is the high-level "magical REST" entrypoint: app code defines
    /// model commands/views and mounts the generated router directly.
    pub async fn serve_autonomous_model<M>(
        &self,
        name: impl Into<String>,
    ) -> Result<axum::Router>
    where
        M: PersistAutonomousRestModel,
    {
        let handle = self.open_autonomous_model::<M>(name).await?;
        Ok(M::mount_router(handle))
    }

    /// Opens a compatibility adapter for legacy vector-style API usage.
    pub async fn open_vec_legacy<V>(
        &self,
        name: impl Into<String>,
    ) -> Result<LegacyPersistVecAdapter<V>>
    where
        V: PersistCollection,
    {
        let managed = self.open_vec::<V>(name).await?;
        Ok(LegacyPersistVecAdapter::new(managed))
    }

    /// Builds the snapshot file path for a logical collection name.
    ///
    /// Unsupported filename characters are normalized to `_`.
    fn snapshot_path_for(&self, vec_name: &str) -> PathBuf {
        let sanitized = vec_name
            .chars()
            .map(|c| {
                if c.is_ascii_alphanumeric() || c == '-' || c == '_' {
                    c
                } else {
                    '_'
                }
            })
            .collect::<String>();
        self.root.join(format!("{sanitized}.snapshot.json"))
    }
}
