use std::{path::PathBuf, sync::Arc};

use async_trait::async_trait;
use chrono::Utc;
use rustmemodb::{
    DbError, ManagedConflictKind, ManagedPersistVec, PersistApp, PersistEntityFactory,
    PersistMetadata, PersistState, classify_managed_conflict, persist_struct, persist_vec,
};
use serde_json::json;
use tokio::sync::Mutex;
use uuid::Uuid;

use crate::{
    domain::{
        errors::DomainError,
        user::{NewUser, PaginatedUsers, SortOrder, User, UserListQuery, UserSortBy},
    },
    infrastructure::UserRepository,
};

persist_vec!(pub UserVec, User);

persist_struct!(
    pub struct UserEmailClaim {
        email: String,
        user_persist_id: String,
    }
);
persist_vec!(pub UserEmailClaimVec, UserEmailClaim);

#[derive(Clone)]
pub struct PersistUserStore {
    state: Arc<Mutex<PersistStoreState>>,
}

struct PersistStoreState {
    users: ManagedPersistVec<UserVec>,
    email_claims: ManagedPersistVec<UserEmailClaimVec>,
}

impl PersistUserStore {
    pub async fn open(data_dir: PathBuf) -> Result<Self, DomainError> {
        let app = PersistApp::open_auto(data_dir)
            .await
            .map_err(map_db_error)?;

        let users = app
            .open_vec::<UserVec>("users")
            .await
            .map_err(map_db_error)?;
        let email_claims = app
            .open_vec::<UserEmailClaimVec>("user_email_claims")
            .await
            .map_err(map_db_error)?;

        Ok(Self {
            state: Arc::new(Mutex::new(PersistStoreState {
                users,
                email_claims,
            })),
        })
    }
}

#[async_trait]
impl UserRepository for PersistUserStore {
    async fn create(&self, user: NewUser) -> Result<User, DomainError> {
        let normalized_email = user.email.trim().to_lowercase();

        let mut state = self.state.lock().await;

        // ID is generated by persistence layer (User::new), never by service/repository caller.
        let new_user = User::new(normalized_email.clone(), user.display_name, user.active);
        let new_user_persist_id = new_user.persist_id().to_string();

        // We enforce uniqueness through a dedicated durable claim collection.
        // Claim id == normalized email, so duplicate email attempts collide at storage key level.
        let claim =
            build_email_claim(&normalized_email, &new_user_persist_id).map_err(map_db_error)?;
        state
            .email_claims
            .create(claim)
            .await
            .map_err(map_db_error)?;

        if let Err(err) = state.users.create(new_user.clone()).await {
            // Best-effort compensation: if user write fails after claim was reserved,
            // release the claim to avoid dangling uniqueness locks.
            let _ = state.email_claims.delete(&normalized_email).await;
            return Err(map_db_error(err));
        }

        state
            .users
            .get(&new_user_persist_id)
            .cloned()
            .ok_or_else(|| {
                DomainError::internal(
                    "user write committed but user is missing in managed collection state",
                )
            })
    }

    async fn find_by_email(&self, email: &str) -> Result<Option<User>, DomainError> {
        let normalized = email.trim().to_lowercase();
        let state = self.state.lock().await;

        let found = state
            .users
            .list()
            .iter()
            .find(|candidate| candidate.metadata().persisted && candidate.email() == &normalized)
            .cloned();

        Ok(found)
    }

    async fn get_by_id(&self, id: Uuid) -> Result<Option<User>, DomainError> {
        let needle = id.to_string();
        let state = self.state.lock().await;
        let found = state
            .users
            .get(&needle)
            .filter(|candidate| candidate.metadata().persisted)
            .cloned();
        Ok(found)
    }

    async fn list(&self, query: UserListQuery) -> Result<PaginatedUsers, DomainError> {
        let state = self.state.lock().await;

        let mut items = state
            .users
            .list()
            .iter()
            .filter(|candidate| candidate.metadata().persisted)
            .cloned()
            .collect::<Vec<_>>();

        if let Some(active) = query.active {
            items.retain(|candidate| *candidate.active() == active);
        }

        if let Some(email_contains) = query.email_contains.as_ref() {
            items.retain(|candidate| candidate.email().contains(email_contains));
        }

        items.sort_by(|left, right| {
            let ordering = match query.sort_by {
                UserSortBy::CreatedAt => left.created_at().cmp(&right.created_at()),
                UserSortBy::Email => left.email().cmp(right.email()),
                UserSortBy::DisplayName => left.display_name().cmp(right.display_name()),
            };
            match query.sort_order {
                SortOrder::Asc => ordering,
                SortOrder::Desc => ordering.reverse(),
            }
        });

        let total = u64::try_from(items.len()).unwrap_or(u64::MAX);
        let total_pages = if total == 0 {
            0
        } else {
            total.div_ceil(u64::from(query.per_page)) as u32
        };

        let paged_items = items
            .into_iter()
            .skip(query.offset())
            .take(usize::try_from(query.per_page).unwrap_or(usize::MAX))
            .collect();

        Ok(PaginatedUsers {
            items: paged_items,
            page: query.page,
            per_page: query.per_page,
            total,
            total_pages,
        })
    }
}

fn build_email_claim(email: &str, user_persist_id: &str) -> rustmemodb::Result<UserEmailClaim> {
    // Avoid generating random claim ids for uniqueness records.
    // The stable claim key (normalized email) is what makes uniqueness durable across restarts.
    let state = PersistState {
        persist_id: email.to_string(),
        type_name: UserEmailClaim::entity_type_name().to_string(),
        table_name: UserEmailClaim::default_table_name(),
        metadata: PersistMetadata::new(Utc::now()),
        fields: json!({
            "email": email,
            "user_persist_id": user_persist_id,
        }),
    };

    <UserEmailClaim as PersistEntityFactory>::from_state(&state)
}

fn map_db_error(error: DbError) -> DomainError {
    if is_unique_conflict(&error) {
        return DomainError::conflict("email already exists");
    }

    DomainError::Storage(error.to_string())
}

fn is_unique_conflict(error: &DbError) -> bool {
    if matches!(
        classify_managed_conflict(error),
        Some(ManagedConflictKind::UniqueConstraint)
    ) {
        return true;
    }

    error
        .to_string()
        .to_ascii_lowercase()
        .contains("unique constraint")
}
