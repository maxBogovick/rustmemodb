use std::{path::PathBuf, sync::Arc};

use rustmemodb::{PersistApp, PersistDomainError, PersistDomainStore, persist_vec};
use tokio::sync::Mutex;
use uuid::Uuid;

use crate::domain::{
    errors::DomainError,
    user::{
        NewUser, PaginatedUsers, SortOrder, UpdateUserPatch, User, UserAuditEvent,
        UserLifecycleCommand, UserListQuery, UserPatch, UserSortBy,
    },
};

persist_vec!(pub UserVec, User);

#[derive(Clone)]
pub struct UserWorkspace {
    state: Arc<Mutex<UserWorkspaceState>>,
}

struct UserWorkspaceState {
    // Keep the autonomous aggregate in workspace state: application code speaks
    // in business commands and does not orchestrate audit/session/tx internals.
    users: PersistDomainStore<UserVec>,
    failpoints: UserWorkspaceFailpoints,
}

#[derive(Default)]
struct UserWorkspaceFailpoints {
    #[cfg_attr(not(test), allow(dead_code))]
    lifecycle_after_user_mutation: bool,
}

impl UserWorkspace {
    pub async fn open(data_dir: PathBuf) -> Result<Self, DomainError> {
        let app = PersistApp::open_auto(data_dir).await.map_err(map_low_level_error)?;
        let users = app
            .open_domain::<UserVec>("users")
            .await
            .map_err(map_low_level_error)?;

        Ok(Self {
            state: Arc::new(Mutex::new(UserWorkspaceState {
                users,
                failpoints: UserWorkspaceFailpoints::default(),
            })),
        })
    }

    pub async fn create(&self, input: NewUser) -> Result<User, DomainError> {
        let mut state = self.state.lock().await;
        let normalized_email = input.email.trim().to_lowercase();

        // ID is generated by persistence layer (User::new), never by caller.
        let new_user = User::new(normalized_email, input.display_name, input.active);
        state
            .users
            .create_one(new_user)
            .await
            .map_err(map_persist_domain_error)
    }

    pub async fn find_by_email(&self, email: &str) -> Result<Option<User>, DomainError> {
        let state = self.state.lock().await;
        let normalized = email.trim().to_lowercase();
        Ok(state.users.find_first(|candidate| candidate.email() == &normalized))
    }

    pub async fn get_by_id(&self, id: Uuid) -> Result<Option<User>, DomainError> {
        let state = self.state.lock().await;
        let needle = id.to_string();
        Ok(state.users.get(&needle).cloned())
    }

    pub async fn list(&self, query: UserListQuery) -> Result<PaginatedUsers, DomainError> {
        let state = self.state.lock().await;
        let active = query.active;
        let email_contains = query.email_contains.clone();
        let sort_by = query.sort_by;
        let sort_order = query.sort_order;

        let page = state.users.query_page_filtered_sorted(
            query.page,
            query.per_page,
            move |candidate| {
                if let Some(active) = active {
                    if *candidate.active() != active {
                        return false;
                    }
                }

                if let Some(needle) = email_contains.as_ref() {
                    if !candidate.email().contains(needle) {
                        return false;
                    }
                }

                true
            },
            move |left, right| {
                let ordering = match sort_by {
                    UserSortBy::CreatedAt => left.created_at().cmp(&right.created_at()),
                    UserSortBy::Email => left.email().cmp(right.email()),
                    UserSortBy::DisplayName => left.display_name().cmp(right.display_name()),
                };
                match sort_order {
                    SortOrder::Asc => ordering,
                    SortOrder::Desc => ordering.reverse(),
                }
            },
        );

        Ok(PaginatedUsers {
            items: page.items,
            page: page.page,
            per_page: page.per_page,
            total: page.total,
            total_pages: page.total_pages,
        })
    }

    pub async fn update(
        &self,
        id: Uuid,
        patch: UpdateUserPatch,
    ) -> Result<User, DomainError> {
        let mut state = self.state.lock().await;

        // Part B DX rule: app code calls business-level patch API.
        // Persist resolves current version/conflict handling internally.
        state
            .users
            .patch_one(
                &id.to_string(),
                UserPatch {
                    display_name: patch.display_name,
                    active: patch.active,
                    ..Default::default()
                },
            )
            .await
            .map_err(map_persist_domain_error)
    }

    pub async fn delete(&self, id: Uuid) -> Result<(), DomainError> {
        let mut state = self.state.lock().await;
        // Part B DX rule: remove without explicit optimistic-lock plumbing in app layer.
        state
            .users
            .remove_one(&id.to_string())
            .await
            .map_err(map_persist_domain_error)
    }

    pub async fn apply_lifecycle_command(
        &self,
        id: Uuid,
        command: UserLifecycleCommand,
    ) -> Result<User, DomainError> {
        let mut state = self.state.lock().await;
        let UserWorkspaceState { users, failpoints } = &mut *state;
        let persist_id = id.to_string();

        #[cfg(test)]
        if failpoints.lifecycle_after_user_mutation {
            let Some(expected_version) = users
                .get(&persist_id)
                .map(|existing| existing.metadata().version)
            else {
                return Err(DomainError::not_found("user not found"));
            };

            return users
                .apply_injected_failure(
                    &persist_id,
                    expected_version,
                    command,
                    "failpoint: lifecycle_after_user_mutation",
                )
                .await
                .map_err(map_low_level_error)?
                .ok_or(DomainError::not_found("user not found"));
        }

        let _ = failpoints;
        // Business intent only; audit persistence/transactions stay under persist internals.
        users
            .intent_one(&persist_id, command)
            .await
            .map_err(map_persist_domain_error)
    }

    pub async fn bulk_apply_lifecycle_command(
        &self,
        ids: &[Uuid],
        command: UserLifecycleCommand,
    ) -> Result<u64, DomainError> {
        let mut state = self.state.lock().await;
        let persist_ids = ids.iter().map(Uuid::to_string).collect::<Vec<_>>();

        state
            .users
            .intent_many(&persist_ids, command)
            .await
            .map_err(map_low_level_error)
    }

    pub async fn list_events(&self, id: Uuid, limit: u32) -> Result<Vec<UserAuditEvent>, DomainError> {
        let state = self.state.lock().await;
        let needle = id.to_string();

        let mut records = state
            .users
            .list_audits_for(&needle)
            .into_iter()
            .collect::<Vec<_>>();

        records.sort_by(|left, right| {
            right
                .metadata()
                .created_at
                .cmp(&left.metadata().created_at)
                .then_with(|| right.persist_id().cmp(left.persist_id()))
        });

        let mut events = Vec::new();
        for record in records
            .into_iter()
            .take(usize::try_from(limit).unwrap_or(usize::MAX))
        {
            events.push(UserAuditEvent {
                id: record.persist_id().to_string(),
                user_id: id,
                event_type: record.event_type().to_string(),
                message: record.message().to_string(),
                resulting_version: *record.resulting_version(),
                created_at: record.metadata().created_at,
            });
        }

        Ok(events)
    }
}

#[cfg(test)]
impl UserWorkspace {
    async fn set_failpoint_lifecycle_after_user_mutation(&self, enabled: bool) {
        let mut state = self.state.lock().await;
        state.failpoints.lifecycle_after_user_mutation = enabled;
    }
}

fn map_persist_domain_error(error: PersistDomainError) -> DomainError {
    match error {
        PersistDomainError::NotFound => DomainError::not_found("user not found"),
        PersistDomainError::ConflictConcurrent(_) => {
            DomainError::conflict("concurrent update conflict")
        }
        PersistDomainError::ConflictUnique(_) => DomainError::conflict("email already exists"),
        PersistDomainError::Validation(message) => DomainError::validation(message),
        PersistDomainError::Internal(message) => DomainError::Storage(message),
    }
}

fn map_low_level_error(error: impl Into<PersistDomainError>) -> DomainError {
    map_persist_domain_error(error.into())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[tokio::test]
    async fn lifecycle_failpoint_rolls_back_user_and_audit_event() {
        let temp = tempdir().expect("temp dir");
        let data_dir = temp.path().join("user_workspace_failpoint");
        let store = UserWorkspace::open(data_dir)
            .await
            .expect("store should open");

        let created = store
            .create(NewUser {
                email: "rollback@example.com".to_string(),
                display_name: "Rollback".to_string(),
                active: true,
            })
            .await
            .expect("seed user");
        let user_id = created.id().expect("valid user id");
        let initial_version = created.version();

        store
            .set_failpoint_lifecycle_after_user_mutation(true)
            .await;

        let result = store
            .apply_lifecycle_command(user_id, UserLifecycleCommand::Deactivate)
            .await;
        assert!(
            result.is_err(),
            "failpoint should force rollback before audit append"
        );
        let err = result
            .err()
            .expect("error must be present when failpoint is enabled");
        assert!(matches!(
            err,
            DomainError::Storage(message) if message.contains("lifecycle_after_user_mutation")
        ));

        let persisted = store
            .get_by_id(user_id)
            .await
            .expect("load user")
            .expect("user should still exist");
        assert_eq!(*persisted.active(), true, "user mutation must roll back");
        assert_eq!(
            persisted.version(),
            initial_version,
            "optimistic version must roll back"
        );

        let events = store.list_events(user_id, 10).await.expect("load events");
        assert!(
            events.is_empty(),
            "audit append must not happen when transaction fails"
        );

        store
            .set_failpoint_lifecycle_after_user_mutation(false)
            .await;

        let updated = store
            .apply_lifecycle_command(user_id, UserLifecycleCommand::Deactivate)
            .await
            .expect("command should succeed after disabling failpoint");
        assert_eq!(*updated.active(), false);

        let events = store
            .list_events(user_id, 10)
            .await
            .expect("load events after success");
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].event_type, "set_active");
    }

    #[tokio::test]
    async fn bulk_lifecycle_writes_bulk_audit_labels() {
        let temp = tempdir().expect("temp dir");
        let data_dir = temp.path().join("user_workspace_bulk_audit");
        let store = UserWorkspace::open(data_dir)
            .await
            .expect("store should open");

        let first = store
            .create(NewUser {
                email: "bulk-1@example.com".to_string(),
                display_name: "Bulk One".to_string(),
                active: false,
            })
            .await
            .expect("seed first user");
        let second = store
            .create(NewUser {
                email: "bulk-2@example.com".to_string(),
                display_name: "Bulk Two".to_string(),
                active: false,
            })
            .await
            .expect("seed second user");

        let processed = store
            .bulk_apply_lifecycle_command(
                &[first.id().expect("first id"), second.id().expect("second id")],
                UserLifecycleCommand::Activate,
            )
            .await
            .expect("bulk lifecycle command");
        assert_eq!(processed, 2);

        let first_events = store
            .list_events(first.id().expect("first id"), 10)
            .await
            .expect("first events");
        assert_eq!(first_events.len(), 1);
        assert_eq!(first_events[0].event_type, "bulk_set_active");

        let second_events = store
            .list_events(second.id().expect("second id"), 10)
            .await
            .expect("second events");
        assert_eq!(second_events.len(), 1);
        assert_eq!(second_events[0].event_type, "bulk_set_active");
    }
}
